import shlex
import subprocess
from ftplib import FTP

from langchain.tools import tool
from telnetlib3 import open_connection

from .utils import TelnetConnection

ftp_server: FTP = None
telnet_connection = TelnetConnection()


@tool
def commandline(command: str):
    """
    This tool executes a command on the command line and returns the output.
    Can only run a single command at a time. The input to this tool should be a string containing the command to run.

    Example usage:
    Action Input: ls
    Action Input: python --version
    """

    disallowed_commands = ["rm", "mkfs", "dd", "shutdown", "reboot", "ftp"]

    try:
        command = command.strip("'\"`")
        command_parts = shlex.split(command)
    except ValueError as e:
        return f"Error: Invalid command syntax - {e}"

    if any(cmd in command_parts for cmd in disallowed_commands):
        return "Error: Command not allowed for security reasons."

    if command.startswith("ftp"):
        return "Ftp commands are not allowed. Use the ftpactions tool instead."

    try:
        process = subprocess.Popen(
            command_parts, stdout=subprocess.PIPE, stderr=subprocess.PIPE
        )
        stdout, stderr = process.communicate(timeout=120)

        output = stdout.decode().strip() or stderr.decode().strip()

        if len(output) > 2000:
            output = output[:2000] + "\n... [Output truncated]"

        return output or "No output or error."

    except subprocess.TimeoutExpired:
        return "Error: Command timed out after 120 seconds."

    except Exception as e:
        return f"Error: {e}"


@tool
def msfconsole(command: str):
    """
    Executes a command in the Metasploit console and returns the output.
    Can only run a single command at a time. The input should be a string containing the command to run.

    Example usage:
    Action Input: use auxiliary/scanner/http/wordpress_login_enum
    Action Input: set RHOSTS 192.168.1.1
    """

    # Remove surrounding quotes if present
    command = command.strip("'\"`")

    # Safely parse the command
    try:
        parsed_command = shlex.split(command)
    except ValueError as e:
        return f"Error: Invalid command syntax - {e}"

    # Prepare the msfconsole command
    msf_command = f'msfconsole -q -x "{parsed_command}"; exit;'

    try:
        # Execute the command
        process = subprocess.Popen(
            msf_command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE
        )
        stdout, stderr = process.communicate(timeout=120)

        # Return the relevant output
        if stdout:
            return stdout.decode()
        else:
            return f"Error: {stderr.decode()}"

    except subprocess.TimeoutExpired:
        return "Error: Command timed out after 120 seconds."
    except Exception as e:
        return f"Error: {e}"


@tool
def ftpactions(command: str):
    """
    Connects to an FTP server and performs operations like ls, cd, put, get.
    Keeps the connection alive. Executes commands like a console.

    Commands:
    - connect <ip> <username> <password>
    - ls
    - cd <relative_path>
    - put <local file or directory>
    - get <remote file or directory>

    Example usage:
    Action input: connect 10.0.11.16 anonymous
    Action input: ls
    Action input: put local_file.txt
    Action input: get folder
    """
    global ftp_server
    cmd, *args = command.split()

    try:
        if cmd == "connect":
            ftp_server = FTP(*args)
            return f"Connected to {args[0]} successfully.\nTo continue using FTP, use Action: ftpactions"

        if not ftp_server:
            raise Exception("Connect to FTP server first!")

        if cmd == "ls":
            directory_listing = []
            ftp_server.dir(lambda x: directory_listing.append(x))
            return f"Contents of {ftp_server.pwd()}:\n" + "\n".join(directory_listing)

        if cmd == "cd":
            ftp_server.cwd(args[0])
            return f"Changed directory to {args[0]}."

        if cmd == "put":
            with open(args[0], "rb") as file:
                ftp_server.storbinary(f"STOR {args[0]}", file)
            return f"Successfully uploaded {args[0]}."

        if cmd == "get":
            with open(args[0], "wb") as file:
                ftp_server.retrbinary(f"RETR {args[0]}", file.write)
            return f"Successfully downloaded {args[0]}."

        return "Error: Unknown command. Use 'connect', 'ls', 'cd', 'put', or 'get'."

    except Exception as e:
        return f"Error: {e}"


@tool
async def telnetactions(command: str):
    """
    Connects to a server using Telnet and performs operations like execute, cpfr_cpto.
    Keeps the connection alive. Accepts a single command at a time.
    Commands:
    - connect <ip_address> <port>
    - execute <command>
    - cpfr_cpto <path/to/copied/file> <path/to/pasted/file>

    Example usage:
    Action input: connect 192.158.24.21
    Action input: execute ls -l
    Action input: cpfr_cpto /path/from /path/to
    """
    global telnet_connection
    parts = command.split()
    cmd = parts[0]

    try:
        if cmd == "connect":
            ip, port = parts[1], int(parts[2]) if len(parts) > 2 else 23
            reader, writer = await open_connection(ip, port)
            telnet_connection.reader = reader
            telnet_connection.writer = writer
            return f"Connected to {ip}:{port}"

        if not telnet_connection.writer:
            return "Error: Not connected to any server."

        if cmd == "execute":
            exec_cmd = " ".join(parts[1:])
            await telnet_connection.writer.write("site " + exec_cmd + "\n")
            response = await telnet_connection.reader.read()
            return response.decode("ascii")

        if cmd == "cpfr_cpto":
            source, destination = parts[1], parts[2]
            telnet_connection.writer.write(f"site cpfr {source}\n")
            telnet_connection.writer.write(f"site cpto {destination}\n")
            return f"File copied from {source} to {destination}"

        return "Error: Unknown command. Use 'connect', 'execute', or 'cpfr_cpto'."

    except Exception as e:
        return f"Error: {e}"


tools = [commandline, ftpactions, telnetactions]
